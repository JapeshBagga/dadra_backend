import{r as n,by as P,bz as k,bA as O,bt as l,bB as U,bC as A,bD as B,bE as L}from"./index-COdFNi2n.js";function I(){const r=n.useRef(!1);return P(()=>(r.current=!0,()=>{r.current=!1}),[]),r}function T(){const r=I(),[o,e]=n.useState(0),s=n.useCallback(()=>{r.current&&e(o+1)},[o]);return[n.useCallback(()=>k.postRender(s),[s]),o]}class D extends n.Component{getSnapshotBeforeUpdate(o){const e=this.props.childRef.current;if(e&&o.isPresent&&!this.props.isPresent){const s=this.props.sizeRef.current;s.height=e.offsetHeight||0,s.width=e.offsetWidth||0,s.top=e.offsetTop,s.left=e.offsetLeft}return null}componentDidUpdate(){}render(){return this.props.children}}function S({children:r,isPresent:o}){const e=n.useId(),s=n.useRef(null),h=n.useRef({width:0,height:0,top:0,left:0}),{nonce:d}=n.useContext(O);return n.useInsertionEffect(()=>{const{width:f,height:u,top:x,left:p}=h.current;if(o||!s.current||!f||!u)return;s.current.dataset.motionPopId=e;const t=document.createElement("style");return d&&(t.nonce=d),document.head.appendChild(t),t.sheet&&t.sheet.insertRule(`
          [data-motion-pop-id="${e}"] {
            position: absolute !important;
            width: ${f}px !important;
            height: ${u}px !important;
            top: ${x}px !important;
            left: ${p}px !important;
          }
        `),()=>{document.head.removeChild(t)}},[o]),l.jsx(D,{isPresent:o,childRef:s,sizeRef:h,children:n.cloneElement(r,{ref:s})})}const v=({children:r,initial:o,isPresent:e,onExitComplete:s,custom:h,presenceAffectsLayout:d,mode:f})=>{const u=U(G),x=n.useId(),p=n.useMemo(()=>({id:x,initial:o,isPresent:e,custom:h,onExitComplete:t=>{u.set(t,!0);for(const c of u.values())if(!c)return;s&&s()},register:t=>(u.set(t,!1),()=>u.delete(t))}),d?[Math.random()]:[e]);return n.useMemo(()=>{u.forEach((t,c)=>u.set(c,!1))},[e]),n.useEffect(()=>{!e&&!u.size&&s&&s()},[e]),f==="popLayout"&&(r=l.jsx(S,{isPresent:e,children:r})),l.jsx(A.Provider,{value:p,children:r})};function G(){return new Map}function H(r){return n.useEffect(()=>()=>r(),[])}const m=r=>r.key||"";function V(r,o){r.forEach(e=>{const s=m(e);o.set(s,e)})}function W(r){const o=[];return n.Children.forEach(r,e=>{n.isValidElement(e)&&o.push(e)}),o}const _=({children:r,custom:o,initial:e=!0,onExitComplete:s,exitBeforeEnter:h,presenceAffectsLayout:d=!0,mode:f="sync"})=>{L(!h,"Replace exitBeforeEnter with mode='wait'");const u=n.useContext(B).forceRender||T()[0],x=I(),p=W(r);let t=p;const c=n.useRef(new Map).current,E=n.useRef(t),C=n.useRef(new Map).current,w=n.useRef(!0);if(P(()=>{w.current=!1,V(p,C),E.current=t}),H(()=>{w.current=!0,C.clear(),c.clear()}),w.current)return l.jsx(l.Fragment,{children:t.map(i=>l.jsx(v,{isPresent:!0,initial:e?void 0:!1,presenceAffectsLayout:d,mode:f,children:i},m(i)))});t=[...t];const b=E.current.map(m),y=p.map(m),F=b.length;for(let i=0;i<F;i++){const a=b[i];y.indexOf(a)===-1&&!c.has(a)&&c.set(a,void 0)}return f==="wait"&&c.size&&(t=[]),c.forEach((i,a)=>{if(y.indexOf(a)!==-1)return;const M=C.get(a);if(!M)return;const K=b.indexOf(a);let g=i;if(!g){const $=()=>{c.delete(a);const j=Array.from(C.keys()).filter(R=>!y.includes(R));if(j.forEach(R=>C.delete(R)),E.current=p.filter(R=>{const z=m(R);return z===a||j.includes(z)}),!c.size){if(x.current===!1)return;u(),s&&s()}};g=l.jsx(v,{isPresent:!1,onExitComplete:$,custom:o,presenceAffectsLayout:d,mode:f,children:M},m(M)),c.set(a,g)}t.splice(K,0,g)}),t=t.map(i=>{const a=i.key;return c.has(a)?i:l.jsx(v,{isPresent:!0,presenceAffectsLayout:d,mode:f,children:i},m(i))}),f==="wait"&&t.length>1&&console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`),l.jsx(l.Fragment,{children:c.size?t:t.map(i=>n.cloneElement(i))})};export{_ as A};
//# sourceMappingURL=index-zJIACDt8.js.map
